Bit Manipulation Properties:

AND:
A & A = A
A & 0 = 0
A & 1 = 1 if A is odd, 0 if A is even

OR:
A | A = A
A | 0 = A

XOR:
A ^ A = 0
A ^ 0 = A

Cumulative properties: Order does not change the result
a & b = b & a
a | b = b | a
a ^ b = b ^ a

Associative property: Grouping does not impact overall result
A & (B & C) = (A & B) & C

LeftShift:
a << n = a * 2^n
1 << n = 2^n

rightShift:
a>>n = a/2^n
1>>n = 1/2^n


Questions:
1. Set ith bit
	To set ith bit of a number, we have to use | (or) operator and answer should be ans = N | (1<<i)
	Example: 1<<4
	Number is :	101101
	1<<4 is		010000
			-----------
			111101

2. Toggle ith bit
	To toggle ith bit, we have to use xor operator. Toggle of N should be : N ^ (1<<i)
	Example: N is 101101 and i =3 then
			101101
		1<<i	001000
			-----------------
			100101
	Here 3rd index toglled from 1 to 0

3. checkbit at perticular idex
	if a bit is 1 which means set at that index else (if 0 means) unset at that index.
	We can do this with the help of & operator at that index
	if(N & (1<<i) == 0){
		ith bit is unset;	
	}
	else{
		ith bit is set;
	}
	
	Solution:
		int checkBit(int n, int i){
			if(n & (1<<i) == 0){
				return 0;
			}
			else{
				return 1;
			}
		}
4. Count number of set bits in N. 
	Example: if N = 12 --> 1100 --> ans = 2;
	approach1: travel over 0 to 32 bits and check checkbit of N & current bit is 1. If it is  1 then count++
	Solution:
	public class solution{
		boolean checkBit(int n, int i){
			if(n & (1<<i) != 0){
				return true;
			}
			else{
				return false;
			}
		}
		int countsetbit(int n){
			int count = 0;
			for(int i=0; i<32; i++){
				if(checkBit(n, i)){
					count++;
				}
			}
			return count;
		}
	}
	approach2: until n >0 check n & 1 !=0 means count++ and do n to rightshift
	Solution:
	public class Solution{
		int countsetbit(int n){
			int count = 0;
			while(n>0){
				if(n & 1 != 0){
					count++;
				}
				n = (n>>1);
			}
			return count;
		}
	}

5. Unset ith bit of a number
	Approach: check wehter the expected bit is already set or not. If it is set then use xor operator to unset it
    public class Solution{
      boolean checkbit(int n, int i){
        if(n & (1<<i) !=0){
            return true;
        }
        else{
            return false;
        }
      }
      int unset(int n , int i){
        if(checkBit(n, i)){
            n = (n ^ (1<<i));
        }
        return n;
      }
    }
6. set bits in a range
    Approach: travel from 0 to B (number of 1's to be added) and set the bits in that range
    Solution:
      public class Solution{
        int setbitRange(int A, int B, int C){
          long solve(int A, int B, int C) {
              long ans = 0;
              for (int i = C; i < B + C; i++) {
                  ans = ans | (1 << i);
              }
              return ans;
        }
        }
      }
